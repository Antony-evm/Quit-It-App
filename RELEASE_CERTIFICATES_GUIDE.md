# Understanding Release Certificates & App Signing

## What Are Release Certificates?

When you build a mobile app for production, you must **cryptographically sign** it to prove:

1. **Who created the app** (authenticity)
2. **The app hasn't been tampered with** (integrity)
3. **You can update the app** (continuity)

Both Android and iOS require signing, but they work differently.

---

## ðŸ¤– Android: Release Keystore

### What is a Keystore?

A **keystore** is a binary file (`.keystore` or `.jks` extension) that contains your app's signing credentials.

**Contents**:

```
quit-it-release.keystore
â”œâ”€â”€ Private Key (secret - used to sign your APK/AAB)
â”œâ”€â”€ Public Certificate (shared - proves the signature is yours)
â””â”€â”€ Metadata (validity dates, algorithm info)
```

**Protected by**:

- **Keystore password**: Protects the entire file
- **Key alias**: Name of your specific key (one keystore can have multiple keys)
- **Key password**: Protects the specific key

### Why It's Critical

**If you lose your keystore**:

- âŒ You can **NEVER** update your app on Google Play
- âŒ You must create a new app with a new package name
- âŒ You lose all users, reviews, and rankings
- âŒ Users can't upgrade - they must uninstall and reinstall

Google Play uses the keystore signature to verify updates come from you. Without the exact same keystore, Google will reject your update as "unauthorized."

### Types of Android Keys

1. **Debug Keystore** (`debug.keystore`)

   - Automatically generated by Android SDK
   - Location: `~/.android/debug.keystore`
   - Password is always: `android`
   - âŒ **NEVER use for production** - it's publicly known!
   - âœ… Fine for development and testing

2. **Release Keystore** (`your-app-release.keystore`)
   - YOU create this yourself
   - YOU choose strong passwords
   - âœ… Used for production builds
   - ðŸ”’ Must be kept EXTREMELY secure

### How to Create an Android Release Keystore

```bash
# Method 1: Using keytool (command-line)
keytool -genkeypair -v \
  -storetype PKCS12 \
  -keystore quit-it-release.keystore \
  -alias quit-it-key \
  -keyalg RSA \
  -keysize 2048 \
  -validity 10000

# You'll be prompted for:
# 1. Keystore password (choose strong, unique password)
# 2. Key password (can be same as keystore password)
# 3. Organization details:
#    - First and Last Name: Your name or "Quit It App"
#    - Organizational Unit: "Development" or "Engineering"
#    - Organization: Your company name
#    - City: Your city
#    - State: Your state/province
#    - Country Code: Two-letter code (US, GB, CA, etc.)
```

**What the command does**:

- `genkeypair`: Generates a key pair (private + public)
- `-storetype PKCS12`: Modern keystore format (recommended)
- `-keystore quit-it-release.keystore`: Output filename
- `-alias quit-it-key`: Name of this key (you'll use this in gradle)
- `-keyalg RSA`: Use RSA encryption algorithm
- `-keysize 2048`: Key strength (2048 bits is standard)
- `-validity 10000`: Valid for 10,000 days (~27 years)

**Method 2: Using Android Studio**:

1. Build â†’ Generate Signed Bundle/APK
2. Create new keystore
3. Fill in the form with same info as above

### Where to Store Your Keystore

**DO** âœ…:

- Store in a password manager (1Password, LastPass, BitWarden)
- Keep encrypted backup in cloud storage (Dropbox, Google Drive - encrypted folder)
- Store in company secret vault (HashiCorp Vault, AWS Secrets Manager)
- Keep physical backup on USB drive in safe location
- Document passwords in secure password manager

**DON'T** âŒ:

- Commit to Git/GitHub
- Email to yourself or others
- Store in plaintext on your computer
- Share the file via Slack/Discord/messaging apps
- Store only in one location (have backups!)

### Using the Keystore in Your App

**File**: `android/gradle.properties` (create if it doesn't exist)

```properties
# DO NOT commit this file to Git!
# Add gradle.properties to .gitignore

MYAPP_RELEASE_STORE_FILE=/absolute/path/to/quit-it-release.keystore
MYAPP_RELEASE_KEY_ALIAS=quit-it-key
MYAPP_RELEASE_STORE_PASSWORD=your_keystore_password_here
MYAPP_RELEASE_KEY_PASSWORD=your_key_password_here
```

**File**: `android/app/build.gradle`

```gradle
android {
    signingConfigs {
        release {
            if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) {
                storeFile file(MYAPP_RELEASE_STORE_FILE)
                storePassword MYAPP_RELEASE_STORE_PASSWORD
                keyAlias MYAPP_RELEASE_KEY_ALIAS
                keyPassword MYAPP_RELEASE_KEY_PASSWORD
            }
        }
    }

    buildTypes {
        release {
            signingConfig signingConfigs.release
            // ... other settings
        }
    }
}
```

### Google Play App Signing (Modern Approach)

Since 2021, Google recommends using **Play App Signing**:

**How it works**:

1. YOU sign your app with your upload key (your keystore)
2. You upload to Google Play
3. GOOGLE re-signs with their own key before distributing to users
4. Google keeps the final signing key secure

**Benefits**:

- âœ… If you lose your upload key, Google can reset it
- âœ… Google manages the final signing key
- âœ… Better security
- âœ… Ability to recover from key compromise

**How to enable** (when you first upload):

1. Go to Google Play Console
2. Create new app
3. During first release, opt-in to "Google Play App Signing"
4. Upload your signing key OR let Google generate one

**Important**: Even with Play App Signing, you still need to create and secure YOUR upload key.

---

## ðŸŽ iOS: Certificates & Provisioning Profiles

iOS signing is more complex than Android. You need:

### 1. Apple Developer Account

**Cost**: $99/year USD

**What it gives you**:

- Ability to publish apps on App Store
- Access to beta testing (TestFlight)
- Push notifications, iCloud, etc.
- Code signing certificates

**Sign up**: https://developer.apple.com/programs/

### 2. Certificates

**Types**:

#### Development Certificate

- **Purpose**: Test on your own device
- **Format**: `.cer` or `.p12` file
- **Who needs it**: Every developer on your team
- **How to create**:
  1. Xcode â†’ Preferences â†’ Accounts â†’ Manage Certificates â†’ +
  2. Or: developer.apple.com â†’ Certificates â†’ +

#### Distribution Certificate

- **Purpose**: Submit to App Store / TestFlight
- **Format**: `.cer` or `.p12` file
- **Limit**: 3 distribution certificates per account
- **How to create**:
  1. developer.apple.com â†’ Certificates â†’ +
  2. Choose "iOS Distribution"
  3. Upload Certificate Signing Request (CSR)
  4. Download certificate
  5. Double-click to install in Keychain

**CSR (Certificate Signing Request)**:

```bash
# Create CSR using Keychain Access (macOS):
1. Open "Keychain Access" app
2. Menu: Keychain Access â†’ Certificate Assistant â†’ Request Certificate from Certificate Authority
3. Enter your email
4. Choose "Saved to disk"
5. Upload the .certSigningRequest file to Apple
```

### 3. Provisioning Profiles

A provisioning profile ties together:

- Your certificate
- Your App ID (bundle identifier, e.g., `com.quititapp`)
- Device IDs (for development/ad-hoc)

**Types**:

#### Development Profile

- For testing on your device
- Includes specific device UDIDs
- Created per-app or wildcard

#### Ad Hoc Profile

- For beta testing outside TestFlight
- Limited to 100 devices
- Must register device UDIDs

#### App Store Profile

- For App Store submission
- No device restrictions
- What you need for production

**How to create**:

1. developer.apple.com â†’ Profiles â†’ +
2. Choose type (Development, Ad Hoc, App Store)
3. Select your App ID
4. Select certificate
5. (For dev/ad-hoc) Select devices
6. Download `.mobileprovision` file

### 4. App ID (Bundle Identifier)

- **What**: Unique identifier for your app
- **Format**: Reverse domain notation (e.g., `com.yourcompany.quititapp`)
- **Where to set**:
  - Xcode project settings
  - developer.apple.com â†’ Identifiers
- **Important**: Must match exactly between:
  - Xcode project
  - App Store Connect
  - Provisioning profiles

**Create**:

1. developer.apple.com â†’ Identifiers â†’ +
2. Choose "App IDs"
3. Enter Bundle ID: `com.quititapp` (or your domain)
4. Enable capabilities (Push Notifications, In-App Purchase, etc.)

### 5. Xcode Configuration

**Open**: `ios/QuitItApp.xcworkspace` (use .xcworkspace, not .xcodeproj!)

**Signing & Capabilities Tab**:

#### Automatic Signing (Easier)

```
âœ… Automatically manage signing
Team: [Your Apple Developer Team]
Bundle Identifier: com.quititapp
```

Xcode handles certificates and profiles automatically.

#### Manual Signing (More Control)

```
âŒ Automatically manage signing
Provisioning Profile (Debug): [Your Development Profile]
Provisioning Profile (Release): [Your App Store Profile]
Signing Certificate (Release): iPhone Distribution
```

### 6. Build Settings

**Key Settings**:

```
Product Bundle Identifier: com.quititapp
Marketing Version: 1.0 (user-facing version)
Current Project Version: 1 (build number)
Code Signing Identity (Release): iPhone Distribution
```

### iOS Signing Workflow

```
1. Enroll in Apple Developer Program ($99/year)
   â†“
2. Create App ID (Bundle Identifier)
   â†“
3. Generate Distribution Certificate
   â†“
4. Create App Store Provisioning Profile
   â†“
5. Download certificate & profile
   â†“
6. Install in Xcode (double-click files)
   â†“
7. Configure in Xcode project
   â†“
8. Archive & Upload to App Store Connect
```

---

## ðŸ” Security Best Practices

### For Android Keystores:

1. **Password Strength**:

   ```
   âŒ BAD:  password123, android, myapp
   âœ… GOOD: K8$mP9#vL2@nQ5^wR7!xT3&zY6
   ```

   Use a password generator in your password manager.

2. **Backup Strategy**:

   - Primary: Password manager (encrypted)
   - Secondary: Encrypted cloud storage
   - Tertiary: Physical USB in safe

3. **Access Control**:

   - Only senior developers should have access
   - Use different keystores for different apps
   - Rotate if compromised

4. **Documentation**:
   ```
   Keystore: quit-it-release.keystore
   Created: December 5, 2025
   Location: [password manager name]
   Alias: quit-it-key
   Validity: 10,000 days (until ~2052)
   Algorithm: RSA 2048-bit
   ```

### For iOS Certificates:

1. **Keychain Protection**:

   - Lock your Mac when away
   - Enable FileVault disk encryption
   - Use strong Mac password

2. **Certificate Backup**:

   - Export certificate + private key as `.p12`
   - Store `.p12` in password manager
   - Document the export password

3. **Team Management**:
   - Use "Admin" role sparingly in App Store Connect
   - Use "App Manager" for most team members
   - Revoke access when team members leave

---

## ðŸš€ CI/CD Considerations

### For Automated Builds:

**Android**:

```bash
# Store in CI/CD secrets (GitHub Actions, GitLab CI, etc.)
KEYSTORE_FILE: [base64 encoded keystore]
KEYSTORE_PASSWORD: [password]
KEY_ALIAS: [alias]
KEY_PASSWORD: [password]

# In build script:
echo $KEYSTORE_FILE | base64 -d > release.keystore
./gradlew assembleRelease
```

**iOS**:

- Use Fastlane Match (manages certificates in git repo - encrypted)
- Or store certificates in CI/CD secrets
- Or use Xcode Cloud (Apple's CI/CD)

---

## ðŸ“‹ Quick Reference

### What You Need Before First Production Release:

**Android**:

- [x] Release keystore generated
- [x] Keystore securely backed up (3+ locations)
- [x] Passwords documented in password manager
- [x] `gradle.properties` configured (not committed to git)
- [x] `build.gradle` updated to use release signing
- [x] Test release build: `./gradlew assembleRelease`

**iOS**:

- [x] Apple Developer account ($99/year)
- [x] App ID created
- [x] Distribution certificate generated
- [x] App Store provisioning profile created
- [x] Xcode signing configured
- [x] App created in App Store Connect
- [x] Test archive build in Xcode

---

## ðŸ†˜ Troubleshooting

### Android: "Failed to read key from keystore"

**Solution**: Check passwords in `gradle.properties` match your keystore

### Android: "KeyStore was tampered with, or password was incorrect"

**Solution**: Wrong keystore password - verify you're using the correct one

### iOS: "No signing certificate found"

**Solution**:

1. Check certificate is installed in Keychain
2. Check it hasn't expired
3. Regenerate if needed

### iOS: "No profiles for 'com.quititapp' were found"

**Solution**:

1. Create provisioning profile on developer.apple.com
2. Download and double-click to install
3. Or enable automatic signing in Xcode

### Android: "App not installed" when testing

**Solution**:

- Existing app was signed with different key
- Uninstall old version first
- Or use different package name

---

## ðŸ“š Additional Resources

**Android**:

- [Official Android App Signing Guide](https://developer.android.com/studio/publish/app-signing)
- [React Native Android Signing](https://reactnative.dev/docs/signed-apk-android)
- [Google Play App Signing](https://support.google.com/googleplay/android-developer/answer/9842756)

**iOS**:

- [Apple Code Signing Guide](https://developer.apple.com/support/code-signing/)
- [About Code Signing](https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/Introduction/Introduction.html)
- [App Distribution Guide](https://developer.apple.com/distribute/)

**Tools**:

- [Fastlane](https://fastlane.tools/) - Automate iOS/Android builds
- [Fastlane Match](https://docs.fastlane.tools/actions/match/) - Certificate management
- [App Center](https://appcenter.ms/) - Build, test, distribute

---

## ðŸ’¡ Summary

**Release certificates are cryptographic credentials that prove you own your app.**

- **Android**: One keystore file + passwords = can update forever
- **iOS**: Multiple certificates + profiles + Apple account = can publish

**Lose them = lose your app.** Treat them like the keys to your house.

Back up multiple times, in multiple secure locations. Document everything. And never, ever commit them to git.
